import { useState, useCallback, useMemo } from "react";
import { isFunction } from "@rpldy/shared";
import { PREVIEW_TYPES } from "./consts";
import { getWithMandatoryOptions, getFallbackUrlData, getFileObjectUrlByType } from "./utils";
const getFilePreviewUrl = (file, options) => {
  let data = getFileObjectUrlByType(PREVIEW_TYPES.IMAGE, options.imageMimeTypes, options.maxPreviewImageSize || 0, file);
  if (!data) {
    data = getFileObjectUrlByType(PREVIEW_TYPES.VIDEO, options.videoMimeTypes, options.maxPreviewVideoSize || 0, file);
  }
  return data;
};
const getItemProps = (previewComponentProps, item, url, type) => {
  return isFunction(previewComponentProps) ? previewComponentProps(item, url, type) : previewComponentProps;
};
const loadPreviewData = (item, options, removeItemFromPreview) => {
  let data,
    isFallback = false;
  if (item.file) {
    const file = item.file;
    data = getFilePreviewUrl(item.file, options);
    if (!data) {
      data = getFallbackUrlData(options.fallbackUrl, file);
      isFallback = true;
    }
  } else {
    data = {
      url: item.url,
      name: item.url,
      type: PREVIEW_TYPES.IMAGE
    };
  }
  return data && {
    ...data,
    id: item.id,
    isFallback,
    removePreview: () => removeItemFromPreview(item.id)
  };
};
const mergePreviewData = (prev, next) => {
  const newItems = [];
  next.forEach(n => {
    const existingIndex = prev.findIndex(p => p.id === n.id);
    if (~existingIndex) {
      prev.splice(existingIndex, 1, n);
    } else {
      newItems.push(n);
    }
  });
  return prev.concat(newItems);
};
const getPreviewsDataWithItemProps = (previewsData, items, previewComponentProps) => {
  let newData = previewsData;
  if (previewComponentProps) {
    newData = previewsData.map(pd => ({
      ...pd,
      props: getItemProps(previewComponentProps, items.find(({
        id
      }) => id === pd.id), pd.url, pd.type)
    }));
  }
  return newData;
};
const getPreviewsLoaderHook = batchItemsMethod => {
  return props => {
    const {
      previewComponentProps,
      rememberPreviousBatches
    } = props || {};
    const [previews, setPreviews] = useState({
      previews: [],
      items: []
    });
    const previewOptions = getWithMandatoryOptions(props);
    const clearPreviews = useCallback(() => {
      setPreviews({
        previews: [],
        items: []
      });
    }, []);
    const removeItemFromPreview = useCallback(id => {
      setPreviews(({
        previews,
        items
      }) => ({
        previews: previews.filter(prev => prev.id !== id),
        items: items.filter(item => item.id !== id)
      }));
    }, []);
    batchItemsMethod(batch => {
      const items = previewOptions.loadFirstOnly ? batch.items.slice(0, 1) : batch.items;
      const previewsData = items.map(item => loadPreviewData(item, previewOptions, removeItemFromPreview)).filter(Boolean);
      setPreviews({
        previews: rememberPreviousBatches ? mergePreviewData(previews.previews, previewsData) : previewsData,
        items: rememberPreviousBatches ? previews.items.concat(items) : items
      });
    });
    const previewsWithItemProps = useMemo(() => getPreviewsDataWithItemProps(previews.previews, previews.items, previewComponentProps), [previews, previewComponentProps]);
    return {
      previews: previewsWithItemProps,
      clearPreviews,
      removeItemFromPreview
    };
  };
};
export { getPreviewsLoaderHook };